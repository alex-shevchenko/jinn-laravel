<?php


namespace Jinn\Laravel\Generator;


use Doctrine\DBAL\Exception as DBALException;
use Illuminate\Console\OutputStyle;
use Illuminate\Support\Str;
use InvalidArgumentException;
use Jinn\Generator\AbstractModelGenerator;
use Jinn\Definition\Models\Entity;
use Jinn\Definition\Models\Relation;
use Jinn\Generator\PhpFileWriter;
use LogicException;
use Nette\PhpGenerator\PhpFile;

class ModelGenerator extends AbstractModelGenerator
{
    private string $baseFolder;
    private string $appFolder;
    private string $appNamespace;
    private string $modelsNamespace;
    private string $generatedNamespace;
    private string $generatedFolder;
    private string $migrationsPath;
    /**
     * @var OutputStyle
     */
    private OutputStyle $output;

    public function __construct()
    {
        $this->modelsNamespace = config('jinn.models_namespace');
        $this->generatedFolder = config('jinn.generated_folder');
        $this->generatedNamespace = config('jinn.generated_namespace');
    }

    public function setBase($baseFolder, $appFolder, $appNamespace, $migrationsPath) {
        if (!$baseFolder || !$appFolder || !$appNamespace || !$migrationsPath) throw new InvalidArgumentException('Folders and namespace are required');

        $this->baseFolder = $baseFolder;
        $this->appFolder = $appFolder;
        $this->appNamespace = $appNamespace;
        $this->migrationsPath = $migrationsPath;
    }

    public function setOutput(OutputStyle $output)
    {
        $this->output = $output;
    }

    protected function writeLine(string $line)
    {
        if ($this->output) $this->output->writeln($line);
    }

    private function name(...$parts) {
        return implode('\\', $parts);
    }

    private function nameToPath($baseFolder, $baseNamespace, $name) {
        $name = str_replace($baseNamespace, $baseFolder, $name);
        return str_replace('\\', '/', $name) . '.php';
    }

    protected function generateModel(Entity $entity): void
    {
        if (!$this->baseFolder) throw new LogicException('Base folder not defined');

        $modelNamespace = $this->name($this->appNamespace, $this->modelsNamespace);
        $genNamespace = $this->name($this->generatedNamespace, $this->modelsNamespace);
        $genName = 'Base' . $entity->name;
        $genFullName = $this->name($genNamespace, $genName);

        $genFile = new PhpFile();
        $genFile->addComment("Generated by Jinn. Do not edit.");
        $genNamespace = $genFile->addNamespace($genNamespace);
        $genClass = $genNamespace->addClass($genName);
        $genClass->setExtends('Illuminate\Database\Eloquent\Model');
        $genClass->setAbstract(true);

        $defaults = [];
        foreach ($entity->fields() as $field) {
            if ($field->noModel) continue;

            $phpType = Types::toPhp($field->type);
            $genClass->addComment("@property " . ($phpType ? $phpType . ($field->required ? '' : '|null') : '') . " \$$field->name");

            if ($field->default)
                $defaults[$field->name] = $field->default;
        }
        if ($defaults) {
            $defaultsProperty = $genClass->addProperty('attributes', $defaults);
            $defaultsProperty->setProtected();
        }

        foreach ($entity->relations() as $relation) {
            $method = $genClass->addMethod($relation->name);
            $method->setPublic();

            $code = 'return $this->';
            $field = $relation->field ? Str::snake($relation->field) : null;
            switch ($relation->type) {
                case Relation::ONE_TO_MANY:
                    $code .= "hasMany(";
                    break;
                case Relation::MANY_TO_ONE:
                    $code .= "belongsTo(";
                    break;
                case Relation::MANY_TO_MANY:
                    $code .= "belongsToMany(";
                    break;
            }
            $code .= "\\$modelNamespace\\{$relation->entityName}::class";
            if ($field) $code .= ", '$field'";
            $code .= ');';
            $method->setBody($code);
        }
        PhpFileWriter::writePhpFile($this->nameToPath($this->generatedFolder, $this->generatedNamespace, $genFullName), $genFile);
        $this->writeLine("Generated class\t<info>$genName</info>");

        $modelFilename = $this->nameToPath($this->appFolder, $this->appNamespace, $this->name($modelNamespace, $entity->name));
        if (!file_exists($modelFilename)) {
            $modelFile = new PhpFile();
            $modelNamespace = $modelFile->addNamespace($modelNamespace);
            $modelNamespace->addUse($genFullName);
            $modelClass = $modelNamespace->addClass($entity->name);
            $modelClass->setExtends($genFullName);

            PhpFileWriter::writePhpFile($modelFilename, $modelFile);
            $this->writeLine("Generated class\t<info>{$entity->name}</info>");
        } else {
            $this->writeLine("Skipped class\t<info>{$entity->name}</info>");
        }
    }

    /**
     * @param array $entities
     * @throws DBALException
     */
    protected function generateMigrations(array $entities): void
    {
        $creator = new MigrationCreator();

        foreach ($entities as $entity) {
            $filename = $creator->createStructureMigration($entity, $this->migrationsPath);
            if ($filename) $this->writeLine("Generated migration <info>$filename</info>");

        }
        foreach ($entities as $entity) {
            $filename = $creator->createForeignKeysMigration($entity, $this->migrationsPath);
            if ($filename) $this->writeLine("Generated migration <info>$filename</info>");
        }
    }
}
